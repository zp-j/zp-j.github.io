<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Top K Frequent Items Algorithm | Ox333333</title><meta name="description" content="Top K frequent elements is a classic interview question that requires candidate to know HashMap, Heap and some basic sorting algorithms."><meta name="keywords" content="LeetCode, Min-Count Sketch, Loosy Counting, HashMap, Heap, Bucket Sort, Date Stream, Algorithm, System Design, Top K Frequent, Interview, 面试, 算法, 系统设计"><meta name="subtitle" content="In Pursuit of Absolute Simplicity"><meta name="author" content="Ox333333"><meta name="google-site-verification" content="cvPAyZ-ZCL95oXwVejN2W-cxTBfUemEGQOnHKDEQ8Dk"><meta name="msvalidate.01" content="31FA25C5697C3CA088656A9B63A9013F"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="og:site_name" content="Ox333333"><meta name="og:type" content="website"><meta name="og:title" content="Top K Frequent Items Algorithm"><meta name="og:descricption" content="Top K frequent elements is a classic interview question that requires candidate to know HashMap, Heap and some basic sorting algorithms."><meta name="og:url" content="https://zpjiang.me/2017/11/13/top-k-elementes-system-design/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Top K Frequent Items Algorithm"><meta name="twitter:description" content="Top K frequent elements is a classic interview question that requires candidate to know HashMap, Heap and some basic sorting algorithms."><meta name="twitter:site" content="@Ox333333"><meta name="twitter:url" content="https://zpjiang.me/2017/11/13/top-k-elementes-system-design/"><link rel="canonical" href="https://zpjiang.me/2017/11/13/top-k-elementes-system-design/"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://zpjiang.me/atom.xml" title="Ox333333"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://blog.1pixel.cc" target="_blank" class="nav-list-link">TRAVEL</a></li><li class="nav-list-item"><a href="https://1pixel.cc" target="_blank" class="nav-list-link">PHOTOGRAPHY</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Top K Frequent Items Algorithm</h1><div class="post-info">Nov 13, 2017</div><div class="post-content"><p>Top K frequent elements is a classic interview question that requires a basic understanding of HashMap and Heap. In this post, we will start with a <a target="_blank" rel="noopener" href="https://leetcode.com/problems/top-k-frequent-elements/description/">leetcode question</a> to see how to use HashMap and sorting to solve this problem in a single machine. After that we will dig deep into a system design question if we want top k frequent elements from a data stream, the second problem can also be referred as <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Streaming_algorithm#Heavy_hitters">Heavy Hitters</a>.</p>
<span id="more"></span>
<h3 id="Basic-Question"><a href="#Basic-Question" class="headerlink" title="Basic Question"></a>Basic Question</h3><p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p>For example,<br>Given <code>[1,1,1,2,2,3]</code> and k = 2, return <code>[1,2]</code>.</p>
<p>Note:</p>
<ul>
<li>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</li>
</ul>
<h4 id="Solution-1-HashMap-Heap"><a href="#Solution-1-HashMap-Heap" class="headerlink" title="Solution 1: HashMap + Heap"></a>Solution 1: HashMap + Heap</h4><p>This solution is very straight forward, it stores all the elements in a HashMap that maps elements to their frequencies, then inserts all the map entry to a max heap so as to get the ones with the highest frequency. The time complexity is <em>O(nlogn)</em> and space complexity is <em>O(n)</em>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">        map.put(n, map.getOrDefault(n,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; maxHeap =</span><br><span class="line">                     <span class="keyword">new</span> PriorityQueue&lt;&gt;((a,b) -&gt; (b.getValue() - a.getValue()));</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;</span><br><span class="line">        maxHeap.add(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(res.size()&lt;k)&#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; entry = maxHeap.poll();</span><br><span class="line">        res.add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Solution-2-Bucket-Sort"><a href="#Solution-2-Bucket-Sort" class="headerlink" title="Solution 2: Bucket Sort"></a>Solution 2: Bucket Sort</h4><p>Since sorting takes <em>O(nlogn)</em>, can we accelerate the sorting process by using extra space? The answer is yes, bucket sort.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt;[] bucket = <span class="keyword">new</span> List[nums.length + <span class="number">1</span>];</span><br><span class="line">    Map&lt;Integer, Integer&gt; frequencyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        frequencyMap.put(n, frequencyMap.getOrDefault(n, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> key : frequencyMap.keySet()) &#123;</span><br><span class="line">        <span class="keyword">int</span> frequency = frequencyMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (bucket[frequency] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bucket[frequency] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[frequency].add(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pos = bucket.length - <span class="number">1</span>; pos &gt;= <span class="number">0</span> &amp;&amp; res.size() &lt; k; pos--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket[pos] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.addAll(bucket[pos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Top-K-Frequent-Elements-in-a-Data-Stream-System-Design"><a href="#Top-K-Frequent-Elements-in-a-Data-Stream-System-Design" class="headerlink" title="Top K Frequent Elements in a Data Stream (System Design)"></a>Top K Frequent Elements in a Data Stream (System Design)</h3><p>If we replace the input array with a data stream, it becomes harder for a single machine to store everything in a single HashMap, it’s also impossible to perform sorting for such large data set. Let’s see what can we do if we can use multi machines to handle this work.</p>
<h4 id="Solution-1-Multi-HashMap-heap"><a href="#Solution-1-Multi-HashMap-heap" class="headerlink" title="Solution 1: Multi HashMap + heap"></a>Solution 1: Multi HashMap + heap</h4><p>We can split the data into <code>n</code> shardings and move a record to a instance respectively. <code>Instance0</code> only handles the data with its hash code equals <code>hash(item) % n == 0</code>, <code>Instance1</code> only handles the data with <code>hash(item) % n == 1</code>, etc.</p>
<p>For each instance, we have a HashMap and Heap to store the items as in the <a href="#Solution-1-HashMap-Heap">first solution for the leetcode question</a>.</p>
<p>In order to retrieve the global top k elements, we only need to gather the heaps from all the instances and run a merge sort, it’s very similar to the leetcode question: <a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-k-sorted-lists/description/">23. Merge k Sorted Lists</a>.</p>
<p>Even though we distribute the work load to multiple machines to reduce the data size to <code>1/n</code>, it’s still not the optimal way to handle large data set in daily work.</p>
<h4 id="Solution-2-Count-Min-Sketch-Heap"><a href="#Solution-2-Count-Min-Sketch-Heap" class="headerlink" title="Solution 2: Count-Min Sketch + Heap"></a>Solution 2: Count-Min Sketch + Heap</h4><p>There are many ways to perform approximate calculation, <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch">Count-Min Sketch</a> is one of them.</p>
<p>Assume that we have <code>d</code> hash functions, create a hash table <code>T</code> with <code>d</code> rows and <code>m</code> cols.</p>
<p>For each item read from data stream, get its hash values from <code>d</code> hash functions and perform mod operations respectively by <code>m</code>. Increase the value by one for each position <code>T[hash_func][hash_value]</code>, we call it <strong>sketch</strong>.</p>
<p>When we want to query the frequency of a particular item, we get its <code>d</code> sketches, return the smallest sketch. As a matter of fact, each of the sketch can be used as its approximate frequency, here we use the minimum sketch.</p>
<p><img src="https://raw.githubusercontent.com/0x333333/hexo_img/master/count-min-sketch.jpg" alt="count-min-sketch" style="max-width: 75%;"/></p>
<p>The idea behind Sketch is very similar to <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom Filter</a>, they both use multiple hashing functions to resolve conflicts. The space complexity for Count-Min Sketch is <em>O(dm)</em>, the time complexity is <em>O(n)</em>.</p>
<p>The advantage of Count-Min Sketch is it saves massive space cost, making it possible to store stream data in memory. The disadvantage is, for those items with low frequency, the min sketch has a higher chance to represent a high frequent items, not low frequent items. However, what we care here is top frequent items, not top least frequent items.</p>
<h4 id="Solution-3-Lossy-Counting"><a href="#Solution-3-Lossy-Counting" class="headerlink" title="Solution 3: Lossy Counting"></a>Solution 3: Lossy Counting</h4><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lossy_Count_Algorithm">Lossy Counting Algorithm</a> is another approximate algorithm to identify elements in a data stream whose frequency count exceed a user-given threshold. Let’s start with a simple example.</p>
<p><strong>Step 1</strong>: Build a HashMap to store the mapping from element to its frequency.</p>
<p><strong>Step 2</strong>: Build a data frame (window).</p>
<p><img src="https://micvog.files.wordpress.com/2015/06/step_1_lossy_counting.png" style="max-width:70%" /></p>
<p><strong>Step 3</strong>: Read data from stream and put them in the data frame, get all their frequencies <code>f</code> and <strong>minus 1</strong>.</p>
<p><img src="https://micvog.files.wordpress.com/2015/06/step_2_lossy_counting.png" style="max-width:70%" /></p>
<p><strong>Step 4</strong>: Update the item frequencies to HashMap, remove the items whose frequency equals to 0 from the HashMap.</p>
<p><img src="https://micvog.files.wordpress.com/2015/06/step_3_lossy_counting.png" style="max-width:70%" /></p>
<p><strong>Step 5</strong>: Repeat Step 3.</p>
<p>The basic idea is, it is less possible for a high frequent item to get removed from the map even though all of them have to be decreased by one for each round. As we read more data, low frequent items will be removed from HashMap and high frequent items stay.</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a target="_blank" rel="noopener" href="https://micvog.com/2015/07/18/frequency-counting-algorithms-over-data-streams/">Frequency Counting Algorithms over Data Streams</a></li>
<li><a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1612.02636.pdf">Efficient Distinct Heavy Hitters for DNS DDoS Attack Detection</a></li>
<li><a target="_blank" rel="noopener" href="http://theory.stanford.edu/~tim/s17/l/l2.pdf">CS168: The Modern Algorithmic Toolbox Lecture #2: Approximate Heavy Hitters and the Count-Min Sketch</a></li>
<li><a target="_blank" rel="noopener" href="https://soulmachine.gitbooks.io/system-design/content/cn/bigdata/heavy-hitters.html">Heavy Hitters</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2017/11/20/Build-iputils-from-CentOS/" class="prev">上一篇</a><a href="/2017/11/11/interviews-result/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zhipeng';
var disqus_identifier = '2017/11/13/top-k-elementes-system-design/';
var disqus_title = 'Top K Frequent Items Algorithm';
var disqus_url = 'http://zpjiang.me/2017/11/13/top-k-elementes-system-design/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zhipeng.disqus.com/count.js" async></script><div class="copyright"><p>2013 - 2021 | <a href="http://zpjiang.me">Ox333333</a> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/3.0/">| CC BY-NC-SA</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async data-ad-client="ca-pub-9383149074803575" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-47515905-1",'auto');ga('send','pageview');</script></body></html>