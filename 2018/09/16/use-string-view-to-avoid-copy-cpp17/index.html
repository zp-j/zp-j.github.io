<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Use std::string_view to avoid string copy in C++17 | Ox333333</title><meta name="description" content="Use std::string_view in C++17 to avoid string copy and achieve big performance boost."><meta name="keywords" content="C++, C++17, string_view, string, std, absl, performance, optimization, pointer, efficiency, best practice"><meta name="subtitle" content="In Pursuit of Absolute Simplicity"><meta name="author" content="Ox333333"><meta name="google-site-verification" content="cvPAyZ-ZCL95oXwVejN2W-cxTBfUemEGQOnHKDEQ8Dk"><meta name="msvalidate.01" content="31FA25C5697C3CA088656A9B63A9013F"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="og:site_name" content="Ox333333"><meta name="og:type" content="website"><meta name="og:title" content="Use std::string_view to avoid string copy in C++17"><meta name="og:descricption" content="Use std::string_view in C++17 to avoid string copy and achieve big performance boost."><meta name="og:url" content="https://zpjiang.me/2018/09/16/use-string-view-to-avoid-copy-cpp17/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Use std::string_view to avoid string copy in C++17"><meta name="twitter:description" content="Use std::string_view in C++17 to avoid string copy and achieve big performance boost."><meta name="twitter:site" content="@Ox333333"><meta name="twitter:url" content="https://zpjiang.me/2018/09/16/use-string-view-to-avoid-copy-cpp17/"><link rel="canonical" href="https://zpjiang.me/2018/09/16/use-string-view-to-avoid-copy-cpp17/"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://zpjiang.me/atom.xml" title="Ox333333"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://blog.1pixel.cc" target="_blank" class="nav-list-link">TRAVEL</a></li><li class="nav-list-item"><a href="https://1pixel.cc" target="_blank" class="nav-list-link">PHOTOGRAPHY</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Use std::string_view to avoid string copy in C++17</h1><div class="post-info">Sep 16, 2018</div><div class="post-content"><h2 id="Tl-dr"><a href="#Tl-dr" class="headerlink" title="Tl;dr"></a>Tl;dr</h2><p>In some cases, the newly introduced <code>std::string_view</code> in C++17 is faster than <code>std::string</code>, because <code>string_view</code> only needs the pointer to the first element and the length of the string sequence, it omits string copy and provides an immutable-view of original data.</p>
<span id="more"></span>
<h2 id="What-is-std-string-view"><a href="#What-is-std-string-view" class="headerlink" title="What is std::string_view?"></a>What is std::string_view?</h2><blockquote>
<p>The class template <code>basic_string_view</code> describes an object that can refer to a constant contiguous sequence of char-like objects with the <strong>first element of the sequence at position zero</strong>.</p>
<p style="text-align: right;"><em>from</em> <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/string/basic_string_view">cppreference.com</a></p>
</blockquote>
<p>The purpose of <code>string_view</code> is to avoid copying data which is already owned somewhere else and of which only a non-mutating view is required, e.g. called as const reference from a function. The idea is to <strong>store a pair of pointer-of-first-element and size of the string</strong>.</p>
<p>For example, there are multiple ways to create a function where it needs (const) string reference. You might be familiar with the first two examples, but there are some problem.</p>
<h2 id="When-to-use-std-string-view"><a href="#When-to-use-std-string-view" class="headerlink" title="When to use std::string_view?"></a>When to use std::string_view?</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TakesCharStar</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span>;             <span class="comment">// C convention</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TakesString</span><span class="params">(<span class="keyword">const</span> string&amp; s)</span></span>;             <span class="comment">// Old Standard C++ convention</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TakesStringView</span><span class="params">(absl::string_view s)</span></span>;     <span class="comment">// Abseil C++ convention</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TakesStringView</span><span class="params">(std::string_view s)</span></span>;      <span class="comment">// C++17 C++ convention</span></span><br></pre></td></tr></table></figure>
<p>If you already have a string, but the interface needs a <code>const char*</code>, it is acceptable but not convenient by calling <code>c_str()</code> function to convert it.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;The string we have&quot;</span>;</span><br><span class="line">    <span class="built_in">TakesCharStar</span>(s.<span class="built_in">c_str</span>());       <span class="comment">// explicit conversion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you already have a char pointer, but the interface needs a <code>const string</code>, you can pass the char pointer directly without calling any conversion method, however, it invokes the creation of a temporary string, copying the contents of that string, O(n) time.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* s = <span class="string">&quot;The char pointer we have&quot;</span>;</span><br><span class="line">    <span class="built_in">TakesString</span>(s);                 <span class="comment">// requires string copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Can we do better? <code>string_view</code> can handle both cases gracefully and efficiently.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;The string we have&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* s2 = <span class="string">&quot;The char pointer we have&quot;</span>;</span><br><span class="line">    <span class="built_in">TakesStringView</span>(s1);</span><br><span class="line">    <span class="built_in">TakesStringView</span>(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>string_view</code> provides implicit conversion constructors that accept both char pointer and const string reference. Since they only need the pointer to the first char and the length of the string, they donâ€™t introduce any string copy.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runs in O(1).</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Allocator&gt;</span><br><span class="line"><span class="built_in">string_view</span>(</span><br><span class="line">    <span class="keyword">const</span> std::basic_string&lt;<span class="keyword">char</span>, std::char_traits&lt;<span class="keyword">char</span>&gt;, Allocator&gt;&amp;</span><br><span class="line">        str) <span class="keyword">noexcept</span></span><br><span class="line">    : <span class="built_in">ptr_</span>(str.<span class="built_in">data</span>()), <span class="built_in">length_</span>(<span class="built_in">CheckLengthInternal</span>(str.<span class="built_in">size</span>())) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Runs in O(n) as `strlen()` or `__builtin_strlen` is called.</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">string_view</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    : ptr_(str), length_(CheckLengthInternal(StrLenInternal(str))) &#123;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="What-else"><a href="#What-else" class="headerlink" title="What else"></a>What else</h2><p><code>string_view</code> can bring a huge performance gain. Letâ€™s borrow two examples from <a target="_blank" rel="noopener" href="https://www.bfilipek.com/2018/07/string-view-perf.html">Performance of std::string_view vs std::string from C++17</a>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string_view&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StringSubStr</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">  std::string s = <span class="string">&quot;Hello Super Extra Programming World&quot;</span>;</span><br><span class="line">  <span class="comment">// Code before the loop is not measured</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">    <span class="keyword">auto</span> str = s.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="comment">// Make sure the variable is not optimized away by compiler</span></span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Register the function as a benchmark</span></span><br><span class="line"><span class="built_in">BENCHMARK</span>(StringSubStr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StringViewSubStr</span><span class="params">(benchmark::State&amp; state)</span> </span>&#123;</span><br><span class="line">  std::string s = <span class="string">&quot;Hello Super Extra Programming World&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> _ : state) &#123;</span><br><span class="line">    std::string_view sv = s;</span><br><span class="line">    <span class="keyword">auto</span> str = sv.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">30</span>);</span><br><span class="line">    benchmark::<span class="built_in">DoNotOptimize</span>(str);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BENCHMARK</span>(StringViewSubStr);</span><br></pre></td></tr></table></figure>
<p>Online benchmark playground: <a target="_blank" rel="noopener" href="http://quick-bench.com/yTktACnG3KGU5-qPgemLv9IIF48">Quick C++ Benchmark</a></p>
<p>Here is the benchmark result, with <code>gcc-8.2</code>, std of <code>c++17</code> and <code>O3</code> as optimization level. Itâ€™s a huge performance improvement.</p>
<p><img src="https://raw.githubusercontent.com/0x333333/hexo_img/master/20180917_bench_mark.png" alt="Huge performance improvement, side by side comparison."></p>
<p><strong>Because itâ€™s O(n) vs O(1).</strong></p>
<p>The key difference is <code>std::string::substr</code> vs <code>std::string_view::substr</code>. The former returns a substring while the latter returns a view of a substring, the former runs in leaner complexity while the latter has constant complexity. Letâ€™s take a look at its implementation in <a target="_blank" rel="noopener" href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/string_view.h#L344">Absel</a>. Skip the input check, to get the substring, basically what it does is simply <strong>move the pointer, no copy, which only has O(1) complexity!</strong>, its performance is independent of the size of the substring.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string_view::substr()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns a &quot;substring&quot; of the `string_view` (at offset `pos` and length</span></span><br><span class="line"><span class="comment">// `n`) as another string_view. This function throws `std::out_of_bounds` if</span></span><br><span class="line"><span class="comment">// `pos &gt; size`.</span></span><br><span class="line"><span class="function">string_view <span class="title">substr</span><span class="params">(size_type pos, size_type n = npos)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ABSL_PREDICT_FALSE</span>(pos &gt; length_))</span><br><span class="line">    base_internal::<span class="built_in">ThrowStdOutOfRange</span>(<span class="string">&quot;absl::string_view::substr&quot;</span>);</span><br><span class="line">  n = std::<span class="built_in">min</span>(n, length_ - pos);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">string_view</span>(ptr_ + pos, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Letâ€™s-switch-to-string-view"><a href="#Letâ€™s-switch-to-string-view" class="headerlink" title="Letâ€™s switch to string_view"></a>Letâ€™s switch to string_view</h2><p>Emm, wait.</p>
<p>Adding <code>string_view</code> to your current code base is not always the best practice, changing the interface to pass by <code>string_view</code> can be <strong>inefficient and sometimes dangerous</strong>, if its inside implementation requires a string or a NULL-terminated const char pointer. For example, function <code>A(const string&amp; s)</code> call <code>B(const char* s)</code>, if you change Aâ€™s interface to <code>A(std::string_view sv)</code>, then you need to handle the conversion from <code>string_view</code> to <code>const char*</code> by calling <code>std::string_view::data()</code>, it can be dangerous because <code>sv</code> is not guaranteed to be NUL-terminated. Therefore, it is encouraged to use <code>string_view</code> starting at the utility code and working upward, or keep the consistency when starting a new project.</p>
<p>Secondly, <strong><code>string_view</code> does not hold the data</strong>. Always keep it in mind that <code>string_view</code> only provides an immutable-view of original data, in another word, the source string must outlive the <code>string_view</code>. A good example is do not create a class member with the type of <code>string_view</code>, itâ€™s hard to guarantee its life cycle.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>By introducing <code>string_view</code>, you can achieve a significant performance boost in string heavy operations. However, always keep these caveats in mind and use it in the right way.</p>
<p><strong>Pros</strong></p>
<ul>
<li>It provides a more flexible interface, can accept both <code>const char*</code> and <code>const string&amp;</code>.</li>
<li>Itâ€™s faster than <code>std::string</code>, in some cases.</li>
</ul>
<p><strong>Cons</strong></p>
<ul>
<li>It is not necessarily NUL-terminated, so in some case like <code>printf</code> itâ€™s not safe.</li>
<li>The source data of the <code>string_view</code> must outlive the <code>string_view</code> itself.</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2019/02/12/Weekend-Basketball-Practice/" class="prev">ä¸Šä¸€ç¯‡</a><a href="/2018/08/08/Copy-Constructor-and-std-vector-emplace-back/" class="next">ä¸‹ä¸€ç¯‡</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zhipeng';
var disqus_identifier = '2018/09/16/use-string-view-to-avoid-copy-cpp17/';
var disqus_title = 'Use std::string_view to avoid string copy in C++17';
var disqus_url = 'http://zpjiang.me/2018/09/16/use-string-view-to-avoid-copy-cpp17/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zhipeng.disqus.com/count.js" async></script><div class="copyright"><p>2013 - 2021 | <a href="http://zpjiang.me">Ox333333</a> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/3.0/">| CC BY-NC-SA</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async data-ad-client="ca-pub-9383149074803575" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-47515905-1",'auto');ga('send','pageview');</script></body></html>