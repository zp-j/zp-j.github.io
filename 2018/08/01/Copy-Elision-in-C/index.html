<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Copy Elision and Return Value Optimization in C++ | Ox333333</title><meta name="description" content="Understand copy elision and return value optimization in C++11, C++14 or later."><meta name="keywords" content="Copy Elision, Return Value Optimization, C++, C++11, C++14, RVO, compiler, Advanced C++, 省略不必要的拷贝"><meta name="subtitle" content="In Pursuit of Absolute Simplicity"><meta name="author" content="Ox333333"><meta name="google-site-verification" content="cvPAyZ-ZCL95oXwVejN2W-cxTBfUemEGQOnHKDEQ8Dk"><meta name="msvalidate.01" content="31FA25C5697C3CA088656A9B63A9013F"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="og:site_name" content="Ox333333"><meta name="og:type" content="website"><meta name="og:title" content="Copy Elision and Return Value Optimization in C++"><meta name="og:descricption" content="Understand copy elision and return value optimization in C++11, C++14 or later."><meta name="og:url" content="https://zpjiang.me/2018/08/01/Copy-Elision-in-C/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Copy Elision and Return Value Optimization in C++"><meta name="twitter:description" content="Understand copy elision and return value optimization in C++11, C++14 or later."><meta name="twitter:site" content="@Ox333333"><meta name="twitter:url" content="https://zpjiang.me/2018/08/01/Copy-Elision-in-C/"><link rel="canonical" href="https://zpjiang.me/2018/08/01/Copy-Elision-in-C/"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://zpjiang.me/atom.xml" title="Ox333333"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://blog.1pixel.cc" target="_blank" class="nav-list-link">TRAVEL</a></li><li class="nav-list-item"><a href="https://1pixel.cc" target="_blank" class="nav-list-link">PHOTOGRAPHY</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Copy Elision and Return Value Optimization in C++</h1><div class="post-info">Aug 1, 2018</div><div class="post-content"><blockquote>
<p>In C++ computer programming, copy elision refers to a compiler optimization technique that eliminates unnecessary copying of objects.<br>…<br>Return value optimization (RVO) is a compiler optimization that involves eliminating the temporary object created to hold a function’s return value.</p>
<p style="text-align: right;"><em>from</em> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Copy_elision">Wikipedia</a></p>
</blockquote>
<span id="more"></span>
<h2 id="Start-with-an-example"><a href="#Start-with-an-example" class="headerlink" title="Start with an example"></a>Start with an example</h2><p>Considering the following code, how many times will the string copy constructor be called?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OneStruct</span> &#123;</span></span><br><span class="line">  vector&lt;string&gt; v;</span><br><span class="line">  <span class="built_in">OneStruct</span>(vector&lt;string&gt; in) &#123;</span><br><span class="line">    v.<span class="built_in">swap</span>(in);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">GenString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">string <span class="title">result</span><span class="params">(<span class="string">&quot;foo&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">GenVector</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  vector&lt;string&gt; result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(<span class="built_in">GenString</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">  <span class="function">OneStruct <span class="title">one_struct</span><span class="params">(GenVector(N))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You might think,</p>
<ul>
<li>In <code>GenString()</code>, <code>foo</code> is returned <code>N</code> times, the constructor is called <code>N</code> times.</li>
<li>In <code>GenVector()</code>, the temporary returned value of <code>GenString()</code> is pushed to vector, that’s another <code>N</code> copy times.</li>
<li>If <code>N</code> is a large number, vector resizes automatically, it will copy values to new vector, roughly speaking, that’s <code>O(N)</code> times. <em>Why? Ask in the comments if you have question.</em></li>
<li>In <code>main()</code>, the temporary returned vector is passed by value to the constructor of OneStruct, <code>O(N)</code> copy times.</li>
<li>In struct, it simply swap the value, <code>O(1)</code> time, no copy.</li>
</ul>
<p>Looks reasonable, but in C++ 11 actual answer is <strong>ZERO</strong>.</p>
<p><strong>As long as there are no two distinct names for the same value, it will not invoke the copy constructor. In the above example, the string can be named as v[0], in[0] or even without name at all (the return value of GenString()), but it never has more than one name at a time. The value is passed by two features: copy elision and move semantics.</strong></p>
<h2 id="Copy-Elision"><a href="#Copy-Elision" class="headerlink" title="Copy Elision"></a>Copy Elision</h2><p>Copy elision happens whenever an object is initialized by copying another object of the same type, and the source object is no longer accessible afterwards, e.g. leave current scope. In this case, compiler treats it as two objects are holding the same place, just skip the copy constructor and replace the place with the new name. There are two major cases where copy elision would happen: <strong>returning a local variable inside a function</strong>, and <strong>initializing a variable with a temporary value</strong>.</p>
<h4 id="Return-a-local-variables"><a href="#Return-a-local-variables" class="headerlink" title="Return a local variables"></a>Return a local variables</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">dosth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  string local_str;</span><br><span class="line">  <span class="comment">// Some operations on local_str.</span></span><br><span class="line">  <span class="keyword">return</span> local_str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string out_str = <span class="built_in">dosth</span>();</span><br></pre></td></tr></table></figure>
<p>Some people prefer to create a function and return a pointer rather than a value, thinking that return a large object is expensive, because it invokes object copy. However, thanks to copy elision, the <code>out_str</code> will take the ownership of the local variable right after the function exits, it’s completely free.</p>
<h4 id="Avoid-object-copy-by-passing-by-value"><a href="#Avoid-object-copy-by-passing-by-value" class="headerlink" title="Avoid object copy by passing by value"></a>Avoid object copy by passing by value</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// It invokes string copy inside.</span></span><br><span class="line"><span class="function">string <span class="title">doA</span><span class="params">(<span class="keyword">const</span> string&amp; a)</span> </span>&#123;</span><br><span class="line">  string local_str = a;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No string copy.</span></span><br><span class="line"><span class="function">string <span class="title">doB</span><span class="params">(string b)</span> </span>&#123;</span><br><span class="line">  string local_str = std::<span class="built_in">move</span>(b);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">doA</span>(<span class="built_in">GenString</span>());</span><br><span class="line"><span class="built_in">doB</span>(<span class="built_in">GenString</span>());</span><br></pre></td></tr></table></figure>
<p>It may come as a surprise if you are accustomed to always passing objects by const-reference for efficiency. In the second function, instead of taking a string by const reference, and then copying it in the function body, it takes the variable by value, and then cheaply move it to local variable. Why? In fact in the second function it moves the copy operation from the function body to outside caller, which happens to meet the condition of copy elision, so it saves the one-time copy operation.</p>
<h2 id="Pay-attention"><a href="#Pay-attention" class="headerlink" title="Pay attention"></a>Pay attention</h2><p><strong>Not all compilers support copy elision, check if it is enabled first.</strong></p>
<p>The primary limitation of copy elision is that it applies only during initialization of the destination object (i.e. when it’s first created), and requires the source object to be completely inaccessible after the copy.</p>
<p><strong>Generally speaking, you should prefer simpler, safer, more readable code, and only go for something more complex if you have concrete evidence that the complex version performs better and that the difference matters. That principle certainly applies to this technique: passing by const reference is simpler and safer, so it’s still a good default choice.</strong> However, if you’re working in an area that’s known to be performance-sensitive, or your benchmarks show that you’re spending too much time copying function parameters, passing by value can be a very useful tool to have in your toolbox.</p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Copy_elision">Copy elision on Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_elision">Copy elision on cppreference.com</a></li>
<li><a target="_blank" rel="noopener" href="https://abseil.io/tips/117">Tip of the Week #117: Copy Elision and Pass-by-value</a></li>
<li><a target="_blank" rel="noopener" href="https://google.github.io/styleguide/cppguide.html#Copyable_Movable_Types">Copyable and Movable Types</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2018/08/08/Copy-Constructor-and-std-vector-emplace-back/" class="prev">上一篇</a><a href="/2018/07/13/Summer-in-Alaska/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zhipeng';
var disqus_identifier = '2018/08/01/Copy-Elision-in-C/';
var disqus_title = 'Copy Elision and Return Value Optimization in C++';
var disqus_url = 'http://zpjiang.me/2018/08/01/Copy-Elision-in-C/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zhipeng.disqus.com/count.js" async></script><div class="copyright"><p>2013 - 2021 | <a href="http://zpjiang.me">Ox333333</a> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/3.0/">| CC BY-NC-SA</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async data-ad-client="ca-pub-9383149074803575" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-47515905-1",'auto');ga('send','pageview');</script></body></html>