<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>The const reference vs pointer in C++ class constructor | Ox333333</title><meta name="description" content="The difference between using const reference and pointers in C++ class constructor is tricky, we should pay attention to the lifetime of the input parameters."><meta name="keywords"><meta name="subtitle" content="In Pursuit of Absolute Simplicity"><meta name="author" content="Ox333333"><meta name="google-site-verification" content="cvPAyZ-ZCL95oXwVejN2W-cxTBfUemEGQOnHKDEQ8Dk"><meta name="msvalidate.01" content="31FA25C5697C3CA088656A9B63A9013F"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="og:site_name" content="Ox333333"><meta name="og:type" content="website"><meta name="og:title" content="The const reference vs pointer in C++ class constructor"><meta name="og:descricption" content="The difference between using const reference and pointers in C++ class constructor is tricky, we should pay attention to the lifetime of the input parameters."><meta name="og:url" content="https://zpjiang.me/2020/01/20/const-reference-vs-pointer/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="The const reference vs pointer in C++ class constructor"><meta name="twitter:description" content="The difference between using const reference and pointers in C++ class constructor is tricky, we should pay attention to the lifetime of the input parameters."><meta name="twitter:site" content="@Ox333333"><meta name="twitter:url" content="https://zpjiang.me/2020/01/20/const-reference-vs-pointer/"><link rel="canonical" href="https://zpjiang.me/2020/01/20/const-reference-vs-pointer/"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://zpjiang.me/atom.xml" title="Ox333333"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://blog.1pixel.cc" target="_blank" class="nav-list-link">TRAVEL</a></li><li class="nav-list-item"><a href="https://1pixel.cc" target="_blank" class="nav-list-link">PHOTOGRAPHY</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">The const reference vs pointer in C++ class constructor</h1><div class="post-info">Jan 20, 2020</div><div class="post-content"><h2 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h2><p>There are many discussions between <strong>reference</strong> and <strong>pointers</strong>, it’s not always true to say “<a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/passing-by-pointer-vs-passing-by-reference-in-c/">use references when you can, and pointers when you have to</a>“. We should pay attention to the lifetime of the input parameters, choose the one that is safer and more efficient according to the use case.</p>
<h2 id="How-to-pass-a-parameter"><a href="#How-to-pass-a-parameter" class="headerlink" title="How to pass a parameter?"></a>How to pass a parameter?</h2><p>Before we talk about const reference vs. pointer in C++ class constructor, let’s take a quick look at different ways of passing a parameter to a function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. Passing by value.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Passing by const reference.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Passing by pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Passing by const pointer.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* a)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">#</th>
<th>parameter</th>
<th style="text-align:center">object copied?</th>
<th style="text-align:center">original object mutable?</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>passing by value</td>
<td style="text-align:center">✔️</td>
<td style="text-align:center">X</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td>passing by const reference</td>
<td style="text-align:center">X</td>
<td style="text-align:center">X</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td>passing by pointer</td>
<td style="text-align:center">X</td>
<td style="text-align:center">✔️</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td>passing by const pointer</td>
<td style="text-align:center">X</td>
<td style="text-align:center">X</td>
</tr>
</tbody>
</table>
<p>As it can easily tell from the table above, <strong>passing by value</strong> introduces an extra object copy, while <strong>passing by pointer</strong> makes the original object mutable.</p>
<p><strong>If you just want to pass some data, do some work with its value without updating it</strong>, you can choose #2 or #4, (don’t pick #1 as it’s could be expensive especially for large object, don’t use #3 as you could mistankenly update its value). Between #2 and #4, I’m leaning to #2 because reference is always non-nullable.</p>
<p><strong>If you want to pass a parameter and update its value</strong>, pick #3 obviously.</p>
<p>I rarely use #1 in daily work.</p>
<span id="more"></span>
<h2 id="Is-passing-const-pointer-always-safe"><a href="#Is-passing-const-pointer-always-safe" class="headerlink" title="Is passing const pointer always safe?"></a>Is passing const pointer always safe?</h2><p>Not really.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; name_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The above example uses <strong>const reference</strong> in a class constructor, it looks perfectly normal, right? What if we initialize <code>Person</code> lie this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">&quot;Ox333&quot;</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; person.<span class="built_in">GetName</span>();  <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>When creating <code>person</code>, the inside field <code>name_</code> is just an alias of the temporary string <code>Ox333</code>. Once <code>person</code> is created, the temporary string goes out of scope, when it tries to print out the name (the content that the alias refers to), it doesn’t exist anymore. The behavior becomes unpredictable!</p>
<p>On OnlineGDB, it prints empty result. Live example: <a target="_blank" rel="noopener" href="https://onlinegdb.com/HyOIEOS-U">https://onlinegdb.com/HyOIEOS-U</a>.</p>
<h2 id="How-to-avoid-this"><a href="#How-to-avoid-this" class="headerlink" title="How to avoid this?"></a>How to avoid this?</h2><p>A straightforward fix is to store the value inside the class, so it’s always accessible, however, it requires an extra copy.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> std::string&amp; name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::string name_;  <span class="comment">// Store the value inside the class!</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Another fix, is to store the const pointer.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// The ownership is outside the class.</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> std::string* name) : <span class="built_in">name_</span>(name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *name_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Not owned, shouldn&#x27;t be null.</span></span><br><span class="line">    <span class="keyword">const</span> std::string* name_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>By doing so, if the caller tries to create a <code>person</code> with a temporary string, the compiler would complain it takes the address of a temporary variable. The unpredictable behavior is avoided proactivey by the compiler.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">GetString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;A string&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SomeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(&amp;GetString())</span></span>;  <span class="comment">// Error: taking address of temporary [-fpermissive]</span></span><br><span class="line">    std::cout &lt;&lt; person.<span class="built_in">GetName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Live example: <a target="_blank" rel="noopener" href="https://onlinegdb.com/B15NNuHWL">https://onlinegdb.com/B15NNuHWL</a>.</p>
<h2 id="Can-we-do-better"><a href="#Can-we-do-better" class="headerlink" title="Can we do better?"></a>Can we do better?</h2><p>We can use <strong>const reference</strong> to enforce the field <code>name_</code> to be non-nullable. By doing so, we don’t need to worry if the field <code>name_</code> is a nullptr or not.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// The ownership is outside the class.</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">const</span> std::string* name) : <span class="built_in">name_</span>(*name) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> std::string&amp; name_;  <span class="comment">// Use const reference to enforce non-nullable.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Check the live example: <a target="_blank" rel="noopener" href="https://onlinegdb.com/Hy9hOurbU">https://onlinegdb.com/Hy9hOurbU</a>.</p>
<h2 id="To-sum-up"><a href="#To-sum-up" class="headerlink" title="To sum up"></a>To sum up</h2><p>There is no such a golden rule telling you when to choose <strong>const reference</strong> or <strong>pointer</strong>, what we can do is to understand how it works, choose the most suitable solution according to the specific case.</p>
</div></article></div></section><footer><div class="paginator"><a href="/2020/02/03/eng-comp-level/" class="prev">上一篇</a><a href="/2020/01/15/let-baidu-index-github-page/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zhipeng';
var disqus_identifier = '2020/01/20/const-reference-vs-pointer/';
var disqus_title = 'The const reference vs pointer in C++ class constructor';
var disqus_url = 'http://zpjiang.me/2020/01/20/const-reference-vs-pointer/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zhipeng.disqus.com/count.js" async></script><div class="copyright"><p>2013 - 2021 | <a href="http://zpjiang.me">Ox333333</a> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/3.0/">| CC BY-NC-SA</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async data-ad-client="ca-pub-9383149074803575" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-47515905-1",'auto');ga('send','pageview');</script></body></html>