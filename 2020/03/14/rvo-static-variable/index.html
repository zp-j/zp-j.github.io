<!DOCTYPE html><html lang="en-US"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>Return Value Optimization disabled for static variable | Ox333333</title><meta name="description" content="Copy elision and return value optimization doesn't work for static variable because it has a program lifetime and can't be moved."><meta name="keywords" content="Static variable, Copy Elision, Return Value Optimization, C++, C++11, C++14, RVO, compiler, Advanced C++, Pointer"><meta name="subtitle" content="In Pursuit of Absolute Simplicity"><meta name="author" content="Ox333333"><meta name="google-site-verification" content="cvPAyZ-ZCL95oXwVejN2W-cxTBfUemEGQOnHKDEQ8Dk"><meta name="msvalidate.01" content="31FA25C5697C3CA088656A9B63A9013F"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="og:site_name" content="Ox333333"><meta name="og:type" content="website"><meta name="og:title" content="Return Value Optimization disabled for static variable"><meta name="og:descricption" content="Copy elision and return value optimization doesn't work for static variable because it has a program lifetime and can't be moved."><meta name="og:url" content="https://zpjiang.me/2020/03/14/rvo-static-variable/"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Return Value Optimization disabled for static variable"><meta name="twitter:description" content="Copy elision and return value optimization doesn't work for static variable because it has a program lifetime and can't be moved."><meta name="twitter:site" content="@Ox333333"><meta name="twitter:url" content="https://zpjiang.me/2020/03/14/rvo-static-variable/"><link rel="canonical" href="https://zpjiang.me/2020/03/14/rvo-static-variable/"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://zpjiang.me/atom.xml" title="Ox333333"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://blog.1pixel.cc" target="_blank" class="nav-list-link">TRAVEL</a></li><li class="nav-list-item"><a href="https://1pixel.cc" target="_blank" class="nav-list-link">PHOTOGRAPHY</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Return Value Optimization disabled for static variable</h1><div class="post-info">Mar 14, 2020</div><div class="post-content"><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>If a function returns a static variable, there won’t be any return value optimization (RVO), as static variable is allocated for the lifetime of the program, it can’t be moved.</p>
<span id="more"></span>
<h2 id="What-are-RVO-amp-Copy-Elision"><a href="#What-are-RVO-amp-Copy-Elision" class="headerlink" title="What are RVO &amp; Copy Elision?"></a>What are RVO &amp; Copy Elision?</h2><blockquote>
<p>In C++ computer programming, copy elision refers to a compiler optimization technique that eliminates unnecessary copying of objects.<br>…<br>Return value optimization (RVO) is a compiler optimization that involves eliminating the temporary object created to hold a function’s return value.</p>
<p style="text-align: right;"><em>from</em> <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Copy_elision">Wikipedia</a></p>
</blockquote>
<p>With the help of RVO and copy elision, it saves the object copy operation (sometimes it could be very expensive on large object) by moving the source object to the new one. More details can be found from <a href="https://zpjiang.me/2018/08/01/Copy-Elision-in-C/">Copy Elision and Return Value Optimization in C++</a>.</p>
<p>There are two cases where copy elision could be applied:</p>
<ul>
<li>returning a local variable inside a function</li>
<li>initializing a variable with a temporary value</li>
</ul>
<h2 id="Static-variable"><a href="#Static-variable" class="headerlink" title="Static variable"></a>Static variable</h2><p>A static variable is allocated only once in a program lifetime in static storage area. They have a scope till the program lifetime.</p>
<p>When a variable is declared as static in a function, space for it gets allocated for the lifetime of the <strong>program</strong>, not the function. Even if the function is called multiple times, space for the static variable is allocated only once and the value of variable in the previous call gets carried through the next function call.</p>
<h2 id="RVO-doesn’t-work-for-static-variable"><a href="#RVO-doesn’t-work-for-static-variable" class="headerlink" title="RVO doesn’t work for static variable"></a>RVO doesn’t work for static variable</h2><p>As static variable has the lifetime of the program, it can’t be moved when the function exits, hence RVO won’t be triggered and copy constructor will be called.</p>
<p>Here’s an example, we define a class <code>Point</code>, explicitly declare its normal constructor and copy construction to tell the difference.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Normal constructor.</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1) &#123;</span><br><span class="line">        x = x1; y = y1;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&gt;&gt; Normal constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy constructor.</span></span><br><span class="line">    <span class="built_in">Point</span>(<span class="keyword">const</span> Point&amp; p2) &#123;</span><br><span class="line">        x = p2.x; y = p2.y;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;&gt;&gt; Copy constructor called.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">Print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + std::<span class="built_in">to_string</span>(x) + <span class="string">&quot;, &quot;</span> + std::<span class="built_in">to_string</span>(y) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Let’s create a program that creates a <code>Point</code> object and prints it’s content.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">GetPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point p = <span class="built_in">GetPoint</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&gt;&gt; &quot;</span> &lt;&lt; p.<span class="built_in">Print</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function <code>GetPoint()</code> initializes a local variable <code>p</code>, returns it directly, the caller takes the return value and initialzes another local variable <code>p</code>. It triggers copy elision and RVO, the output is as below, <strong>no copy operation</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; Normal constructor called.</span><br><span class="line">&gt;&gt; (1, 2)</span><br></pre></td></tr></table></figure>
<p>Let’s add a new function <code>GetConstPoint2()</code> and create a static variable inside.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point <span class="title">GetConstPoint2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Point* p = <span class="keyword">new</span> <span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point p = <span class="built_in">GetPoint</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&gt;&gt; &quot;</span> &lt;&lt; p.<span class="built_in">Print</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Point p2 = <span class="built_in">GetConstPoint2</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&gt;&gt; &quot;</span> &lt;&lt; p2.<span class="built_in">Print</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As the static varialble outlive the scope of the function, it can’t be moved, so RVO can’t be applied here. Here’s the output, <strong>the second run has an extra “Copy constructor called”</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; Normal constructor called.</span><br><span class="line">&gt;&gt; (1, 2)</span><br><span class="line">&gt;&gt; Normal constructor called.</span><br><span class="line">&gt;&gt; Copy constructor called.</span><br><span class="line">&gt;&gt; (1, 2)</span><br></pre></td></tr></table></figure>
<h2 id="Can-we-avoid-the-extra-copy-for-static-variable"><a href="#Can-we-avoid-the-extra-copy-for-static-variable" class="headerlink" title="Can we avoid the extra copy for static variable?"></a>Can we avoid the extra copy for static variable?</h2><p>Yes.</p>
<p>Since it’s a static variable, we don’t have to worry about its lifetime, we can return its pointer to avoid the object copy.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point* <span class="title">GetConstPoint3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Point* p = <span class="keyword">new</span> <span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point p = <span class="built_in">GetPoint</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&gt;&gt; &quot;</span> &lt;&lt; p.<span class="built_in">Print</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Point p2 = <span class="built_in">GetConstPoint2</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&gt;&gt; &quot;</span> &lt;&lt; p2.<span class="built_in">Print</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> Point* p3 = <span class="built_in">GetConstPoint3</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&gt;&gt; &quot;</span> &lt;&lt; p3-&gt;<span class="built_in">Print</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As using a const pointer, we can not only access the variable without an object copy, but also keep it immutable (safe), here’s the output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; Normal constructor called.</span><br><span class="line">&gt;&gt; (1, 2)</span><br><span class="line">&gt;&gt; Normal constructor called.</span><br><span class="line">&gt;&gt; Copy constructor called.</span><br><span class="line">&gt;&gt; (1, 2)</span><br><span class="line">&gt;&gt; Normal constructor called.</span><br><span class="line">&gt;&gt; (1, 2)</span><br></pre></td></tr></table></figure>
<p>Full example code can be found here: <a target="_blank" rel="noopener" href="https://onlinegdb.com/rk0fbM3rI">https://onlinegdb.com/rk0fbM3rI</a>.</p>
<h2 id="Sum-up"><a href="#Sum-up" class="headerlink" title="Sum up"></a>Sum up</h2><p>RVO doesn’t work for static variable, which has been allocated in program lifetime and can’t be moved.</p>
<p>Once we understand how and why copy elision and RVO are helpful to code performance optimization, we would know when to use it and when not to.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://zpjiang.me/2018/08/01/Copy-Elision-in-C/">Copy Elision and Return Value Optimization in C++</a></li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/static-keyword-cpp/">Static Keyword in C++</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2020/05/28/picamera-adjust-focus/" class="prev">上一篇</a><a href="/2020/02/04/fb-eng-comp/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'zhipeng';
var disqus_identifier = '2020/03/14/rvo-static-variable/';
var disqus_title = 'Return Value Optimization disabled for static variable';
var disqus_url = 'http://zpjiang.me/2020/03/14/rvo-static-variable/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//zhipeng.disqus.com/count.js" async></script><div class="copyright"><p>2013 - 2021 | <a href="http://zpjiang.me">Ox333333</a> <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/3.0/">| CC BY-NC-SA</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script async data-ad-client="ca-pub-9383149074803575" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-47515905-1",'auto');ga('send','pageview');</script></body></html>